/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var Samarco = /* color: #d63000 */ee.Geometry.Polygon(
        [[[-43.525, -20.11],
          [-43.525, -20.31],
          [-43.375, -20.31],
          [-43.375, -20.11]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
// This script was originally written by Simon Ilyushchenko (GEE team)
// and adapted by Simon Gascoin (CNRS/CESBIO) and Michel Le  Page (IRD/CESBIO)


// Define ROI and center map
var ROI = Samarco;
var center = ROI.centroid(1);
Map.setCenter(center.coordinates().get(0).getInfo(),
center.coordinates().get(1).getInfo(), 12);

// Define working scale
var SCALE = 30; // meters

// Load Sentinel-1 C-band SAR Ground Range collection (log scaling, VV co-polar)
var collection =  ee.ImageCollection('COPERNICUS/S1_GRD').filterBounds(ROI)
.filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
.select('VV');

// Mosaic images before and after event of interest in specific time ranges
var before = collection.filterDate('2014-01-01', '2015-11-01').mosaic();
var after = collection.filterDate('2015-11-04', '2015-12-31').mosaic();

// Threshold smoothed radar intensities to identify "flooded" areas.
var SMOOTHING_RADIUS = 200;

// Set threshold value
var DIFF_UPPER_THRESHOLD = -4; 

//Topological intersection
var diff_smoothed = after.focal_median(SMOOTHING_RADIUS, 'circle', 'meters')
    .subtract(before.focal_median(SMOOTHING_RADIUS, 'circle', 'meters'));

var diff_thresholded = diff_smoothed.lt(DIFF_UPPER_THRESHOLD);


// Display map
Map.addLayer(before, {min:-20,max:10}, 'Before flood',0);
Map.addLayer(after, {min:-20,max:10}, 'After flood',0);
Map.addLayer(after.subtract(before), {min:-10,max:10}, 'After - before', 0); 
Map.addLayer(diff_smoothed, {min:-10,max:10}, 'diff smoothed', 0); 

//Images of sentinel dataset
// before flood sentinel
 var thump_before= before
      .visualize({opacity:1,bands:["VV"],min:-20,max:10})
      .getThumbURL({dimensions:'500x500',format: 'png', region: ROI.getInfo()});
       print(ROI.getInfo());
       print(thump_before);
       
// after flood sentinel
var thump_after = after
      .visualize({opacity:1,bands:["VV"],min:-20,max:10})
      .getThumbURL({dimensions:'500x500',format: 'png', region: ROI.getInfo()});
       print(ROI.getInfo());
       print(thump_after);
       
//before smoothning
 var flooded_beforesmooth= (after.subtract(before))
      .visualize({opacity:1,bands:["VV"],min:-10,max:10})
      .getThumbURL({dimensions:'500x500',format: 'png', region: ROI.getInfo()});
       print(ROI.getInfo());
       print(flooded_beforesmooth);
       
// after smoothning
 var after_smoothed= diff_smoothed
      .visualize({opacity:1,bands:["VV"],min:-10,max:10})
      .getThumbURL({dimensions:'500x500',format: 'png', region: ROI.getInfo()});
       print(ROI.getInfo());
       print(after_smoothed);
       
//Update flooded area after thresholding
var flood = diff_thresholded.updateMask(diff_thresholded);
Map.addLayer(flood.clip(ROI), {palette:"0000FF"},'flooded areas',0);

// image of flooded area
var flooded_area= flood
      .visualize({opacity:1,bands:["VV"],min:-10,max:10,palette:"0000FF"})
      .getThumbURL({dimensions:'500x500',format: 'png', region: ROI.getInfo()});
       print(ROI.getInfo());
       print(flooded_area);
       
//clean-up of false positive pixels
var floodpoly = flood.unmask().focal_mode({radius:SCALE, iterations:3, units:'meters'});
floodpoly = floodpoly.mask(floodpoly);
Map.addLayer(floodpoly.clip(ROI),{palette:"0000FF"},'flooded areas (3>)',1);

//image of final cleaned flooded area
var cleaned_flooded_area= floodpoly
      .visualize({opacity:1,bands:["VV"],min:-10,max:10,palette:"0000FF"})
      .getThumbURL({dimensions:'500x500',format: 'png', region: ROI.getInfo()});
       print(ROI.getInfo());
       print(cleaned_flooded_area);
       
 //Convert the unmasked pixels to polygons.
var pixel_polys = floodpoly.select('VV').reduceToVectors
({
  geometry: ROI,
  scale: SCALE,
  maxPixels: 1e10,
  crs: 'EPSG:4326'
});


//Population
  var Population = ee.ImageCollection("CIESIN/GPWv4/population-count");
  var clipped = function(img) {
  return img.clip(pixel_polys);
  };
  var cropped_pop = Population.map(clipped);
  var pop = cropped_pop.select('population-count');
  Map.addLayer(cropped_pop,{min: 0, max:5000},'population',1);
  
//add new feature area
pixel_polys = pixel_polys.map
  (function(feature)
    { 
      return feature.set('area', feature.area(SCALE));
    });
    
//Display polygons
Map.addLayer(pixel_polys, {color:'red'}, 'polygons');

var pixel_polysGEOMETRY = pixel_polys.geometry( );
var OneFEATURE  = ee.Feature( pixel_polysGEOMETRY );

// Reduce the region. The region parameter is the Feature geometry.

var pop2015=ee.Image(pop.toList(1,3).get(0));
var popsample= pop2015.sampleRegions({
  collection: pixel_polys,
  properties: ["population-count"],
  scale: SCALE
});


//export flooded area
Export.table.toDrive
    ({
    collection: pixel_polys,
    description: 'flooded_area',
    folder: 'EE_Exports'
    });
