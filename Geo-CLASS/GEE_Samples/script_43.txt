//this script is intended to take a fc of community forests and find analogue regions with similar biophysical and socio-economic characteristics. The pairing will likely 

//be done in multiple steps. A rough outline might be: 



// 1. Find all (some) possible analogues that have similar shapes (area and perimiter?) and similar forest cover characteristics. Use a baseline year for forest cover.

// 2. Do 1 so that each cf starts from a blank image and therefore there will be a lot of overlap 

// 3. Introduce additional biophysical/socio-economic factors so that we can narrow down the possible options for analogue areas 









//import some existing data 

var CFs = ee.FeatureCollection('users/ak_glaciers/All_CF_Cambodia_July_2016'); 

var canopyCover = ee.Image('users/ak_glaciers/reem_cf_outputs/reem_canopy_cover_2000_pts_rma_nbr_timeseries_remapped_full')

var plusMinus = 10; //when we select the thresholds for appropriate forest cover analogues this will determine how far off the CF mean we can be

var numFeats = 2000 //this will produce this many feats per cardnial direction quadrant

var place = 'Cambodia'; 

var aoi = ee.FeatureCollection("USDOS/LSIB/2017").filter(ee.Filter.eq('COUNTRY_NA',place)).geometry()

var moveCoeff = 5; //this will be multiplied by the 0-1 distributed random numbers to define how much polygons are moved









//first get the average canopy cover across the feature - this will have to be put into a map statement



//get the coordinate list of a feature (test- this is just for the first feature in the collection)



var test_feat = CFs.filter(ee.Filter.eq('CF_Name_En','Monorom'))

var test_feat_coords = ee.List(ee.Feature(test_feat.first()).geometry().coordinates()); 

print(test_feat_coords,'test')

print(ee.List(ee.Feature(CFs.first()).geometry().coordinates().get(0)),'og')



var mean_cc = canopyCover.select('yr_2000').reduceRegion({

    reducer:ee.Reducer.mean(), 

    geometry:test_feat.first().geometry(), 

    scale:30

  }); 

  

  print(mean_cc)







//get the mean canopy cover for a feature

var mean_cc = canopyCover.select('yr_2000').reduceRegion({

  reducer:ee.Reducer.mean(), 

  geometry:CFs.first().geometry(), 

  scale:30

}); 



//define a threshold for the example feature - this will need to be wrapped into a map statement

var cc_threshold = ee.Number(mean_cc.get('yr_2000')).round(); 



test_feat = test_feat.set('mean_cc',mean_cc.get('yr_2000')); 



//create a mask that is based on the canopy cover of the CF we're interested in 

canopyCover = canopyCover.select('yr_2000'); 









//now set up to move the features around 

//create some numbers to move the feature around randomly 



//define a function to create a randNumber col

function addRandom(fc,colName){

  return fc.randomColumn({

    columnName:colName,

    seed:5

  }); 

}



var rand_nums_list = ee.List.sequence(0,numFeats); //this is a hardcoded limit for now, that can be changed

var rand_nums = ee.FeatureCollection(rand_nums_list.map(function(x){ 

  x = ee.Number(x).toInt(); 

  var output = ee.Dictionary(['id',x]); 

  return ee.Feature(null,output); 

})); 



//add random numbers for both lat and lon

rand_nums = addRandom(rand_nums,'lon_move');

rand_nums = addRandom(rand_nums,'lat_move'); 



//now make the random number columns bigger. By default its a 0-1 distribution but this won't move the polygon enough to cover the country

rand_nums = rand_nums.map(function(feat){

  return feat.set('lon_move',ee.Number(feat.get('lon_move')).multiply(moveCoeff))

            .set('lat_move',ee.Number(feat.get('lat_move')).multiply(moveCoeff)); 

}); 









//do the moving of the polygon

//define a series of functions that randomly move the polygon around four directional quadrants



function shuffleNW(coords_list,feat){

  var output = coords_list.map(function(coords){

  var first = ee.Number(ee.List(coords).get(0)).subtract(feat.get('lon_move')); 

  var second = ee.Number(ee.List(coords).get(1)).add(feat.get('lat_move'));  

  return ee.List([first,second]); 

  }); 

  return output; 

}



function shuffleSW(coords_list,feat){

  var output = coords_list.map(function(coords){

  var first = ee.Number(ee.List(coords).get(0)).subtract(feat.get('lon_move')); 

  var second = ee.Number(ee.List(coords).get(1)).subtract(feat.get('lat_move'));  

  return ee.List([first,second]); 

  }); 

  return output; 

}



function shuffleSE(coords_list,feat){

  var output = coords_list.map(function(coords){

  var first = ee.Number(ee.List(coords).get(0)).add(feat.get('lon_move')); 

  var second = ee.Number(ee.List(coords).get(1)).subtract(feat.get('lat_move'));  

  return ee.List([first,second]); 

  }); 

  return output; 

}



function shuffleNE(coords_list,feat){

  var output = coords_list.map(function(coords){

  var first = ee.Number(ee.List(coords).get(0)).add(feat.get('lon_move')); 

  var second = ee.Number(ee.List(coords).get(1)).add(feat.get('lat_move'));  

  return ee.List([first,second]); 

  }); 

  return output; 

}



//now build the collection of shuffled polygons. This is currently limited by the length of the list included above.

//these are redundant and could be made more concise 

var nwFC = rand_nums.map(function(feat){

  var geometry = ee.Geometry.Polygon(shuffleNW(test_feat_coords,feat)); 

  var output = ee.Dictionary(['id',feat.get('id')]); 

  return ee.Feature(geometry,output); 

}); 



var swFC = rand_nums.map(function(feat){

  var geometry = ee.Geometry.Polygon(shuffleSW(test_feat_coords,feat)); 

  var output = ee.Dictionary(['id',feat.get('id')]); 

  return ee.Feature(geometry,output); 

}); 



var seFC = rand_nums.map(function(feat){

  var geometry = ee.Geometry.Polygon(shuffleSE(test_feat_coords,feat)); 

  var output = ee.Dictionary(['id',feat.get('id')]); 

  return ee.Feature(geometry,output); 

}); 



var neFC = rand_nums.map(function(feat){

  var geometry = ee.Geometry.Polygon(shuffleNE(test_feat_coords,feat)); 

  var output = ee.Dictionary(['id',feat.get('id')]); 

  return ee.Feature(geometry,output); 

}); 



//the output for the test feature - this will be the output of a mapped statement 

var combined = nwFC.merge(swFC).merge(seFC).merge(neFC); 









//now apply some filters - this isn't a very efficient way to do this but might be an ok first cut

//first just confine to the same country - this doesn't matter physically but will for socio-economic data

combined = combined.filterBounds(aoi); 



//second we make sure that none of the analogues overlap another existing CF

combined = combined.map(function(feat){

  return feat.set('intersects',feat.intersects(CFs.geometry())); 

}); 

combined = combined.filter(ee.Filter.eq('intersects',false)); 



//third get only features that have similar canopy cover to the original feature 

//add a mean canopy cover field to each feature

combined = combined.map(function(feat){

  var mean_cc = canopyCover.reduceRegion({

    reducer:ee.Reducer.mean(), 

    geometry:feat.geometry(), 

    scale:30

  }); 

  return feat.set('cc',ee.Number(mean_cc.get('yr_2000'))); 

}); 

//then do the actual filtering 

//first the lower bound

combined = combined.filter(ee.Filter.gte('cc',cc_threshold.subtract(plusMinus))); 

//then the upper bound

combined = combined.filter(ee.Filter.lte('cc',cc_threshold.add(plusMinus))); 











//export the result because its runs pretty slowly 

Export.table.toAsset({

  collection:combined, 

  description:'CF_randomly_shuffled_featureCollection_all_directions_move_test_'+place, 

  assetId:'reem_cf_outputs/CF_randomly_shuffled_featureCollection_all_directions_move_test_'+place

}); 



//visualize the outputs 










