/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var USA = ee.FeatureCollection("TIGER/2018/States"),
    ChineseP = ee.FeatureCollection("users/eisen520/chinesePrivet");
/***** End of imports. If edited, may not auto-convert in the playground. *****/






var NC = USA.filter(ee.Filter.eq('NAME', 'North Carolina'));



// Show the state polygon with a blue outline

var outline = ee.Image().byte().paint({

  featureCollection: NC,

  color: 1,

  width: 3

});

Map.addLayer(outline, {palette: ['blue']}, 'North Carolina');



//load Chinese Privet to map

Map.centerObject(ChineseP);

Map.addLayer(ChineseP, {color: 'red'}, 'Chinese Privet plots');





//***this is the bug! watch out for the CPpoint, onlt id in the property

var CPpoint = ChineseP.map(function(feature) {

  return ee.Feature(feature.geometry(), {'id': feature.id()}); // here we only keep 1 property

});





// Function to remove cloud and snow pixels

function maskCloudAndShadows(image) {

  var cloudProb = image.select('MSK_CLDPRB');

  var snowProb = image.select('MSK_SNWPRB');

  var cloud = cloudProb.lt(5);

  var snow = snowProb.lt(5);

  var scl = image.select('SCL'); 

  var shadow = scl.eq(3); 

  var cirrus = scl.eq(10); 

  // Cloud probability less than 5% or cloud shadow classification

  var mask = (cloud.and(snow)).and(cirrus.neq(1)).and(shadow.neq(1));

  return image.updateMask(mask);

}



// Adding a NDVI band

function addNDVI(image) {

  var ndvi = image.normalizedDifference(['B8', 'B4']).rename('ndvi');

  return image.addBands([ndvi]);

}

var startDate = '2019-04-01';

var endDate = '2019-6-01';

// Use Sentinel-2 L2A data - which has better cloud masking

var collection = ee.ImageCollection('COPERNICUS/S2_SR')

    .filterDate(startDate, endDate)

    .map(maskCloudAndShadows)

    .map(addNDVI)

    .filter(ee.Filter.bounds(ChineseP));



// View the median composite

var vizParams = {bands: ['B4', 'B3', 'B2'], min: 0, max: 2000};





//pick-up the first point and create a chart

var testPoint = ee.Feature(ChineseP.first());

Map.centerObject(testPoint, 10)

var chart = ui.Chart.image.series({

    imageCollection: collection.select('ndvi'),

    region: testPoint.geometry()

    }).setOptions({

      interpolateNulls: true,

      lineWidth: 1,

      pointSize: 3,

      title: 'NDVI over Time at a Single Location',

      vAxis: {title: 'NDVI'},

      hAxis: {title: 'Date', format: 'YYYY-MMM', gridlines: {count: 12}}

    });





var triplets = collection.map(function(image) {

  return image.select('ndvi').reduceRegions({

    collection: CPpoint, 

    reducer: ee.Reducer.first().setOutputs(['ndvi']), 

    scale: 10,

  })

    // with the point or if the image is masked out due to cloud

    // If there was no ndvi value found, we set the ndvi to a NoData value -9999

    .map(function(feature) {

    var ndvi = ee.List([feature.get('ndvi'), -9999])

      .reduce(ee.Reducer.firstNonNull());

    return feature.set({'ndvi': ndvi, 'imageID': image.id()});

    });

  }).flatten();







var format = function(table, rowId, colId) {

  var rows = table.distinct(rowId); 

  var joined = ee.Join.saveAll('matches').apply({

    primary: rows, 

    secondary: table, 

    condition: ee.Filter.equals({

      leftField: rowId, 

      rightField: rowId

    })

  });

         

  return joined.map(function(row) {

      var values = ee.List(row.get('matches'))

        .map(function(feature) {

          feature = ee.Feature(feature);

          return [feature.get(colId), feature.get('ndvi')];

        });

      return row.select([rowId]).set(ee.Dictionary(values.flatten()));

    });

};



var sentinelResults = format(triplets, 'id', 'imageID');





// There are multiple image granules for the same date processed from the same orbit

// Granules overlap with each other and since they are processed independently

// the pixel values can differ slightly. So the same pixel can have different NDVI 

// values for the same date from overlapping granules.

// So to simplify the output, we can merge observations for each day

// And take the max ndvi value from overlapping observations



var cleanup = function(table, rowId) {

  return table.map(function(feature) {

    var id = feature.get(rowId);

    var allKeys = feature.toDictionary().keys().remove(rowId);

    var substrKeys = ee.List(allKeys.map(function(val) { 

        return ee.String(val).slice(0,8)}

        ));

    var uniqueKeys = substrKeys.distinct();

    var pairs = uniqueKeys.map(function(key) {

      var matches = feature.toDictionary().select(allKeys.filter(ee.Filter.stringContains('item', key))).values();

      var val = matches.reduce(ee.Reducer.max());

      return [key, val];

    });

    return feature.select([rowId]).set(ee.Dictionary(pairs.flatten()));

  });

};



var sentinelMerged = cleanup(sentinelResults, 'id');





var CPtable = ee.FeatureCollection(ChineseP);





var idfilter = ee.Filter.equals({

  leftField: 'id',

  rightField: 'system:index'

});



var tableJoin = ee.Join.inner('primary', 'secondary'); //be careful of the order

var Joinedtable = tableJoin.apply(sentinelMerged, CPtable, idfilter);



// see https://stackoverflow.com/questions/56416772/how-can-i-append-two-featurecollections

var finaltable = Joinedtable.map(function(pair) {

  var f1 = ee.Feature(pair.get('primary'));

  var f2 = ee.Feature(pair.get('secondary'));

  return f1.set(f2.toDictionary());

});



print (finaltable, 'Final Output');



Export.table.toDrive({

    collection: finaltable,

    description: 'NDVI_time_series',

    folder: 'earthengine',

    fileNamePrefix: 'ndvi_time_series',

    fileFormat: 'CSV'

});





// Purge entire queue...

