/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var blocoKayapo = ee.FeatureCollection("users/juandb/bloco_TIs_Kayapo"),
    geometry = /* color: #98ff00 */ee.Geometry.Polygon(
        [[[-54.7943115234375, -12.431212216060944],
          [-55.39031982421875, -13.549881446917126],
          [-53.5968017578125, -13.541870908391582],
          [-53.52264404296875, -12.31853594166211]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
// CALCULO DE MOSAICOS MEIODES LANDSAT 

// ADAPTADO DAS ROTINAS LANDTRENDR







// websites: https://github.com/eMapR/LT-GEE





//##### INPUTS ##### 



// define area of intereset

var aoi = ee.Geometry.Polygon([[

[94.80707325604851,6.4234378960251375],

[99.64105763104851,-8.125532985411112],

[118.27387013104851,-6.905658671812838],

[118.97699513104851,6.16135474378468],

[95.07074513104851,5.811710066240051],

[94.80707325604851,6.4234378960251375]]]);



// define years and dates to include in landsat image collection

var years=[2016,2017]

var startDay  = '01-01'; 

var endDay    = '12-31'; 

// define visualization parameters

var vizParams = {'min': 14.8,'max': [3800,6200,2500],'bands':['swir1','nir','red'], 'gamma':1};



//##### ANNUAL SR TIME SERIES COLLECTION BUILDING FUNCTIONS ##### 





//----- MAKE A DUMMY COLLECTOIN FOR FILLTING MISSING YEARS -----

var dummyCollection = ee.ImageCollection([ee.Image([0,0,0,0,0,0]).mask(ee.Image(0))]); // make an image collection from an image with 6 bands all set to 0 and then make them masked values





//------ L8 to L7 HARMONIZATION FUNCTION -----

// slope and intercept citation: Roy, D.P., Kovalskyy, V., Zhang, H.K., Vermote, E.F., Yan, L., Kumar, S.S, Egorov, A., 2016, Characterization of Landsat-7 to Landsat-8 reflective wavelength and normalized difference vegetation index continuity, Remote Sensing of Environment, 185, 57-70.(http://dx.doi.org/10.1016/j.rse.2015.12.024); Table 2 - reduced major axis (RMA) regression coefficients

var harmonizationRoy = function(oli) {

  var slopes = ee.Image.constant([0.9785, 0.9542, 0.9825, 1.0073, 1.0171, 0.9949]);        // create an image of slopes per band for L8 TO L7 regression line - David Roy

  var itcp = ee.Image.constant([-0.0095, -0.0016, -0.0022, -0.0021, -0.0030, 0.0029]);     // create an image of y-intercepts per band for L8 TO L7 regression line - David Roy

  var y = oli.select(['B2','B3','B4','B5','B6','B7'],['blue', 'green', 'red', 'nir', 'swir1', 'swir2']) // select OLI bands 2-7 and rename them to match L7 band names

             .resample('bicubic')                                                          // ...resample the L8 bands using bicubic

             .subtract(itcp.multiply(10000)).divide(slopes)                                // ...multiply the y-intercept bands by 10000 to match the scale of the L7 bands then apply the line equation - subtract the intercept and divide by the slope

             .set('system:time_start', oli.get('system:time_start'));                      // ...set the output system:time_start metadata to the input image time_start otherwise it is null

  return y.toShort();                                                                       

};





//------ RETRIEVE A SENSOR SR COLLECTION FUNCTION -----

var getSRcollection = function(year, startDay, endDay, sensor, aoi) {

  // get a landsat collection for given year, day range, and sensor

  var srCollection = ee.ImageCollection('LANDSAT/'+ sensor + '/C01/T1_SR') // get surface reflectance images

                       .filterBounds(aoi)                                  // ...filter them by intersection with AOI

                       .filterDate(year+'-'+startDay, year+'-'+endDay)    // ...filter them by year and day range

  

  // apply the harmonization function to LC08 (if LC08), subset bands, unmask, and resample           

  srCollection = srCollection.map(function(img) {

    var dat = ee.Image(

      ee.Algorithms.If(

        sensor == 'LC08',                                                  // condition - if image is OLI

        harmonizationRoy(img.unmask()),                                    // true - then apply the L8 TO L7 alignment function after unmasking pixels that were previosuly masked (why/when are pixels masked)

        img.select(['B1', 'B2', 'B3', 'B4', 'B5', 'B7'])                   // false - else select out the reflectance bands from the non-OLI image

           .unmask()                                                       // ...unmask any previously masked pixels 

           .resample('bicubic')                                            // ...resample by bicubic 

           .set('system:time_start', img.get('system:time_start'))         // ...set the output system:time_start metadata to the input image time_start otherwise it is null

      )



    )

    

    // make a cloud, cloud shadow, and snow mask from fmask band

    var qa = img.select('pixel_qa');                                       // select out the fmask band

    var mask = qa.bitwiseAnd(8).eq(0).and(                                 // include shadow

               qa.bitwiseAnd(16).eq(0)).and(                               // include snow

               qa.bitwiseAnd(32).eq(0));                                   // include clouds

    

    

    return dat.mask(mask); 

  });



  return srCollection; 

};







var getCombinedSRcollection = function(year, startDay, endDay, aoi) {

    var lt5 = getSRcollection(year, startDay, endDay, 'LT05', aoi);       // get TM collection for a given year, date range, and area

    var le7 = getSRcollection(year, startDay, endDay, 'LE07', aoi);       // get ETM+ collection for a given year, date range, and area

    var lc8 = getSRcollection(year, startDay, endDay, 'LC08', aoi);       // get OLI collection for a given year, date range, and area



    var mergedCollection = ee.ImageCollection(lt5.merge(lc8)); // merge the individual sensor collections into one imageCollection object

    return mergedCollection;                                              

};





//------ FUNCTION TO REDUCE COLLECTION TO SINGLE IMAGE PER YEAR BY MEDOID -----

/*

  LT expects only a single image per year in a time series, there are lost of ways to

  do best available pixel compositing - we have found that a mediod composite requires little logic

  is robust, and fast

  

  Medoids are representative objects of a data set or a cluster with a data set whose average 

  dissimilarity to all the objects in the cluster is minimal. Medoids are similar in concept to 

  means or centroids, but medoids are always members of the data set.

*/



// make a medoid composite with equal weight among indices

var medoidMosaic = function(inCollection, dummyCollection) {

  

  // fill in missing years with the dummy collection

  var imageCount = inCollection.toList(1).length();                                                            // get the number of images 

  var finalCollection = ee.ImageCollection(ee.Algorithms.If(imageCount.gt(0), inCollection, dummyCollection)); // if the number of images in this year is 0, then use the dummy collection, otherwise use the SR collection

  

  // calculate median across images in collection per band

  var median = finalCollection.median();                                                                       

  

  // calculate the different between the median and the observation per image per band

  var difFromMedian = finalCollection.map(function(img) {

    var diff = ee.Image(img).subtract(median).pow(ee.Image.constant(2));                                       // get the difference between each image/band and the corresponding band median and take to power of 2 to make negatives positive and make greater differences weight more

    return diff.reduce('sum').addBands(img);                                                                   // per image in collection, sum the powered difference across the bands - set this as the first band add the SR bands to it - now a 7 band image collection

  });

  

  // get the medoid by selecting the image pixel with the smallest difference between median and observation per band 

  return ee.ImageCollection(difFromMedian).reduce(ee.Reducer.min(7)).select([1,2,3,4,5,6], ['blue', 'green', 'red', 'nir', 'swir1', 'swir2']); // find the powered difference that is the least - what image object is the closest to the median of teh collection - and then subset the SR bands and name them - leave behind the powered difference band

};





//------ FUNCTION TO APPLY MEDOID COMPOSITING FUNCTION TO A COLLECTION -------------------------------------------

var buildMosaic = function(year, startDay, endDay, aoi, dummyCollection) {                                                                      // create a temp variable to hold the upcoming annual mosiac

  var collection = getCombinedSRcollection(year, startDay, endDay, aoi);  // get the SR collection

  var img = medoidMosaic(collection, dummyCollection)                     // apply the medoidMosaic function to reduce the collection to single image per year by medoid 

              .set('system:time_start', (new Date(year,8,1)).valueOf())

              .clip(aoi);  // add the year to each medoid image - the data is hard-coded Aug 1st 

  Map.addLayer(img,vizParams,'Mosaico meiode '+year.toString())

  print (img)

  return ee.Image(img);                                                   

};







//------ FUNCTION TO BUILD ANNUAL MOSAIC COLLECTION ------------------------------



var annualSRcollection = ee.ImageCollection(years.map(function(yr){return buildMosaic(yr, startDay, endDay, aoi, dummyCollection);}));






print (annualSRcollection)

Map.addLayer(ee.Image().paint(aoi,1,1), {'palette': '00FFFF'},'Area Estudo');





