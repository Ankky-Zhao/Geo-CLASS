/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var countries = ee.FeatureCollection("FAO/GAUL/2015/level0");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///Edited by Efrain Laverde  - 2021 



// Landsat Composite with cloud masking- 7/5/15



// Written by: RSAC USFS

// contact rsac_gee@fs.fed.us with questions



// Description:

// This script creates cloud free composites of Landsat imagery 

// over user specitied intervals for a user specified geographic area.





// User Editable Variables



// AREA - Composite area

// Create a Feature Collection for the area of interest.

var country_name = ['Colombia'];

var country = countries.filterMetadata('ADM0_NAME', 'equals', 'Colombia');



// Set the variable, studyArea, to point to your FeatureCollection, country.

// Note, you can also load your own Fusion Table as a FeatureCollection. 

// Then set the studyArea, line 24, to the FeatureCollection you created.

var studyArea = country;







// PERIODO DE TIEMPO - Composite time period

// startYear: First year to include imagery from

var startYear = 2000;



// endYear: Last year to include imagery from

var endYear = 2002;



// startJulian: Starting Julian Date- Supports wrapping for tropics and 

//     southern hemisphere

var startJulian = 305;



// endJulian: Ending Julian date- Supports wrapping for tropics and 

//     southern hemisphere

var endJulian = 90;     





// PARAMETROS - Composite parameters

// cloudThresh: If using the cloudScoreTDOMShift method-Threshold for cloud 

//     masking (lower number masks more clouds.  Between 10 and 30 generally 

//     works best)

var cloudThresh = 20; 

   

// dilatePixels: Number of pixels to buffer clouds and cloud 

//     shadows by (1 or 2 generally is sufficient)

var dilatePixels = 2;    

	

// cloudHeights: Height of clouds to use to project cloud shadows

var cloudHeights = ee.List.sequence(200,5000,500);



// zScoreThresh: Threshold for cloud shadow masking- lower number masks out 

// less.  Between -0.8 and -1.2 generally works well

var zScoreThresh = -0.8;    

	

// shadowSumThresh: Sum of IR bands to include as shadows within TDOM and the 

// shadow shift method (lower number masks out less)

var shadowSumThresh = 0.35;    

	



// EXPORTAR - Export parameters

// Give the study area a descriptive name. This name is used for output 

// composites file names.

var exportName = 'Colombia'; 





// For more info- http://spatialreference.org/ref/epsg/  

var crs = 'EPSG:32618'; 



//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// End of user editable parameters. Do not edit anything below this line. Unless you are brave. ;)

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!







// Functions







//Function for acquiring Landsat TOA image collection

function getImageCollection(studyArea,startDate,endDate,startJulian,endJulian){

  var ls;var l4TOAs;var l5TOAs;var l7TOAs;var l8TOAs;var out;

  

  var sensorBandDictLandsatTOA =ee.Dictionary({L8 : ee.List([1,2,3,4,5,9,6]),

                        L7 : ee.List([0,1,2,3,4,5,7]),

                        L5 : ee.List([0,1,2,3,4,5,6]),

                        L4 : ee.List([0,1,2,3,4,5,6])

  });

  var bandNamesLandsatTOA = ee.List(['blue','green','red','nir','swir1','temp',

      'swir2']);



  l4TOAs = ee.ImageCollection('LANDSAT/LT4_L1T_TOA')

      .filterDate(startDate,endDate)

      .filter(ee.Filter.calendarRange(startJulian,endJulian))

      .filterBounds(studyArea)

      .select(sensorBandDictLandsatTOA.get('L4'), bandNamesLandsatTOA);

  

  l5TOAs = ee.ImageCollection('LANDSAT/LT5_L1T_TOA')

      .filterDate(startDate,endDate)

      .filter(ee.Filter.calendarRange(startJulian,endJulian))

      .filterBounds(studyArea)

      .select(sensorBandDictLandsatTOA.get('L5'),bandNamesLandsatTOA);

  

  l8TOAs = ee.ImageCollection('LANDSAT/LC8_L1T_TOA')

      .filterDate(startDate,endDate)

      .filter(ee.Filter.calendarRange(startJulian,endJulian))

      .filterBounds(studyArea)

      .select(sensorBandDictLandsatTOA.get('L8'),bandNamesLandsatTOA);



  l7TOAs = ee.ImageCollection('LANDSAT/LE7_L1T_TOA')

      .filterDate(startDate,endDate)

      .filter(ee.Filter.calendarRange(startJulian,endJulian))

      .filterBounds(studyArea)

      .select(sensorBandDictLandsatTOA.get('L7'),bandNamesLandsatTOA);

  

  ls = ee.ImageCollection(l4TOAs.merge(l5TOAs).merge(l7TOAs).merge(l8TOAs));

  out = ls;

  return out;

}







// A helper to apply an expression and linearly rescale the output.

// Used in the landsatCloudScore function below.

var rescale = function(img, exp, thresholds) {

  return img.expression(exp, {img: img})

      .subtract(thresholds[0]).divide(thresholds[1] - thresholds[0]);

};





// Compute a cloud score and adds a band that represents the cloud mask.  

// This expects the input image to have the common band names: 

// ["red", "blue", etc], so it can work across sensors.

function landsatCloudScore(img) {

  // Compute several indicators of cloudiness and take the minimum of them.

  var score = ee.Image(1.0);

  // Clouds are reasonably bright in the blue band.

  score = score.min(rescale(img, 'img.blue', [0.1, 0.3]));

 

  // Clouds are reasonably bright in all visible bands.

  score = score.min(rescale(img, 'img.red + img.green + img.blue', [0.2, 0.8]));

   

  // Clouds are reasonably bright in all infrared bands.

  score = score.min(

      rescale(img, 'img.nir + img.swir1 + img.swir2', [0.3, 0.8]));



  // Clouds are reasonably cool in temperature.

  score = score.where(img.select(['temp']).mask(),score.min(rescale(img,

      'img.temp', [300, 290])));



  // However, clouds are not snow.

  var ndsi = img.normalizedDifference(['green', 'swir1']);

  score =  score.min(rescale(ndsi, 'img', [0.8, 0.6])).multiply(100).byte();

  score = score.lt(cloudThresh).rename('cloudMask');

  img = img.updateMask(img.mask().and(score));

  return img.addBands(score);

}





//Function for finding dark outliers in time series.

//Original concept written by Carson Stam and adapted by Ian Housman.

//Adds a band that is a mask of pixels that are dark, and dark outliers.

function simpleTDOM2(collection,zScoreThresh,shadowSumThresh,dilatePixels){

  var shadowSumBands = ['nir','swir1'];

  

  //Get some pixel-wise stats for the time series

  var irStdDev = collection.select(shadowSumBands).reduce(ee.Reducer.stdDev());

  var irMean = collection.select(shadowSumBands).mean();

  

  //Mask out dark dark outliers

  collection = collection.map(function(img){

    var zScore = img.select(shadowSumBands).subtract(irMean).divide(irStdDev);

    var irSum = img.select(shadowSumBands).reduce(ee.Reducer.sum());

    var TDOMMask = zScore.lt(zScoreThresh).reduce(ee.Reducer.sum()).eq(2)

        .and(irSum.lt(shadowSumThresh)).not();

    TDOMMask = TDOMMask.focal_min(dilatePixels);

    return img.addBands(TDOMMask.rename('TDOMMask'));

  });

  

  return collection;

}





//Function for wrapping cloud and shadow masking together.

//Assumes image has cloud mask band called "cloudMask" and a TDOM mask called 

//"TDOMMask".

function cloudProject(img,shadowSumThresh,dilatePixels,cloudHeights){

  

  //Get the cloud mask

  var cloud = img.select('cloudMask').not();

  cloud = cloud.focal_max(dilatePixels);

  cloud = cloud.updateMask(cloud);

  

  //Get TDOM mask

  var TDOMMask = img.select(['TDOMMask']).not();

  

  //Project the shadow finding pixels inside the TDOM mask that are dark and 

  //inside the expected area given the solar geometry

  //Find dark pixels

  var darkPixels = img.select(['nir','swir1','swir2'])

      .reduce(ee.Reducer.sum()).lt(shadowSumThresh);

  

  //Get scale of image

  var nominalScale = cloud.projection().nominalScale();



  //Find where cloud shadows should be based on solar geometry

  //Convert to radians

  var meanAzimuth = img.get('SUN_AZIMUTH');

  var meanZenith = img.get('SUN_ELEVATION');

  var azR = ee.Number(meanAzimuth).multiply(Math.PI).divide(180.0)

      .add(ee.Number(0.5).multiply(Math.PI ));

  var zenR = ee.Number(0.5).multiply(Math.PI )

      .subtract(ee.Number(meanZenith).multiply(Math.PI).divide(180.0));

  

  //Find the shadows

  var shadows = cloudHeights.map(function(cloudHeight){

    cloudHeight = ee.Number(cloudHeight);

    var shadowCastedDistance = zenR.tan()

        .multiply(cloudHeight);//Distance shadow is cast

    var x = azR.cos().multiply(shadowCastedDistance)

        .divide(nominalScale).round();//X distance of shadow

    var y = azR.sin().multiply(shadowCastedDistance)

        .divide(nominalScale).round();//Y distance of shadow

    return cloud.changeProj(cloud.projection(), cloud.projection()

        .translate(x, y));

  });



  var shadow = ee.ImageCollection.fromImages(shadows).max();

 

  //Create shadow mask

  shadow = shadow.updateMask(shadow.mask().and(cloud.mask().not()));

  shadow = shadow.focal_max(dilatePixels);

  shadow = shadow.updateMask(shadow.mask().and(darkPixels).and(TDOMMask));



  //Combine the cloud and shadow masks

  var combinedMask = cloud.mask().or(shadow.mask()).eq(0);

  

  

  img = img.updateMask(img.mask().and(combinedMask));

  img = img.addBands(combinedMask.rename(['cloudShadowMask']));

  return img;

}





// Function to calculate NDVI

function ndvi_function(input) {

  var img = input.select("nir", "red").normalizedDifference();

  return img.addBands(input.metadata("system:time_start"));

}







// Run the analysis





// vizParams: Options for map visualization

var vizParams = {'min': 0.05,'max': 0.5, 'bands':'swir1,nir,red', 

    'gamma':1.6};

var vizParamsRescale = {'min': 500,'max': 5000, 'bands':'swir1,nir,red', 

    'gamma':1.6};



Map.addLayer(studyArea, null, "Study Area",true);

Map.centerObject(studyArea, 9);



// Prepare dates

if(startJulian > endJulian){endJulian = endJulian + 365}

var startDate = ee.Date.fromYMD(startYear,1,1).advance(startJulian,'day');

var endDate = ee.Date.fromYMD(endYear,1,1).advance(endJulian,'day');

print('Start and end dates:',startDate,endDate);



// Get Landsat 4,5,8,7 Image Collections

var ls = getImageCollection(studyArea, startDate, endDate, startJulian, endJulian);

Map.addLayer(ls.median().clip(studyArea), vizParams,

  'Landsat before masking composite', false);



// Compute a cloud score and mask clouds

ls = ls.map(landsatCloudScore);



// Find and mask out dark outliers

ls = simpleTDOM2(ls,zScoreThresh,shadowSumThresh,dilatePixels);



// Run cloud project to get the final cloud and shadow masked image collection

ls = ls.map(function(img){return cloudProject(img,shadowSumThresh,dilatePixels,

    cloudHeights)});

	

// Run reducer on image collection 

var composite = ls.median();



// Add the NDVI bands.

var NDVI = ls.map(ndvi_function);    

var minNDVI = NDVI.reduce(ee.Reducer.percentile([10]));

var maxNDVI = NDVI.reduce(ee.Reducer.percentile([90]));

var medNDVI = NDVI.reduce(ee.Reducer.percentile([50]));

var composite =composite.addBands(minNDVI.select(["nd_p10"], ["p10NDVI"]));

var composite =composite.addBands(medNDVI.select(["nd_p50"], ["p50NDVI"]));

var composite =composite.addBands(maxNDVI.select(["nd_p90"], ["p90NDVI"]));



// Get descriptive name.

var fullName = exportName+'_'+startYear.toString()+'_' +endYear.toString()+'_'+startJulian.toString()+'_'+endJulian.toString()+'_Composite';



//Set up the export image.

var toExport = composite.select(

  ['blue','green','red','nir','swir1','swir2', 'p10NDVI', 'p50NDVI', 'p90NDVI']

  ).multiply(10000).int16().clip(studyArea);



// Add the pixel count to the export image.

var count = ls.select("blue").count();

var toExport = toExport.addBands

  (count.select(["blue"], ["pxlcount"])).int16().clip(studyArea);



// Add the final image to display.

Map.addLayer(toExport.clip(studyArea), vizParamsRescale, 

  fullName, true);



// Save the study area coordinates to set the region in the export.

var region = studyArea.geometry().bounds().getInfo().coordinates[0];



// Export the image.

Export.image.toDrive({

  image: toExport,

  description: fullName,

  maxPixels: 1e13, 

  crs: crs,

  region: country,

  scale: 30

  });

