/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var jrc = ee.Image("JRC/GSW1_0/GlobalSurfaceWater");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
// load the required functions
var ls_fun = require('users/eeProject/water_surface_interpolation:functions_landsat.js');
var occ = jrc.select('occurrence');
var calcAreaImage = function(maskImage) {
  return(ee.Image.pixelArea().divide(1000000).mask(maskImage).rename(maskImage.bandNames()));
};
var createParagraphPanel = function(paragraph, labelStyle) {
  var labelList = [];
  for (var i = 0; i < paragraph.length; i++) {
    labelList.push(ui.Label(paragraph[i], labelStyle));
  }
  return(ui.Panel(labelList));
}; 

// set parameters
var MAXDISTANCE = 1000; // used in cumulative_cost function to isolate lake area from water area
var waterClassification = 'Jones2019_3'; 


// load lake polygons
var lake1 = ee.FeatureCollection('users/sarinarinab/CitSci_Washington_Lakes').select(['GNIS_Name', 'AreaSqKm'], ['GNIS_NAME', 'AREASQKM']);
var lake2 = ee.FeatureCollection('users/sntopp/Lakes_ply_20171106');
var lake3 = ee.FeatureCollection('users/sntopp/NCSC_Horsepen_Lake');
var lakes = lake1.merge(lake2).merge(lake3).sort('AREASQKM');
var lakesNames = lakes.aggregate_array('GNIS_NAME');
// load landsat images
var dat = ls_fun.merge_collections_std_bandnames_collection1tier1_sr()
.filterDate('2017-01-01', '2030-01-01');

// get layers of the current map
var layers = Map.layers();


var lakeSelector = ui.Select(lakesNames.getInfo(), 'Select a lake');

lakeSelector.onChange(function(name) {
  
  var f = ee.Feature(lakes.filterMetadata('GNIS_NAME', 'equals', name).first());
  var aoi = f.geometry();
  
  Map.centerObject(aoi);
  
  var result = ee.ImageCollection(ls_fun.filterContained(dat, aoi)).aside(print)
  .map(function(img) {
    var i = ls_fun.CalculateWaterAddFlagsSR(img, waterClassification); // water classificaton method can be changed here
    var aoiBuffered = aoi.buffer(200);
    
    var waterMask = i.select(['waterMask']); // waterMask
    var obsMask = i.select(['fmask']).gte(2).rename(['obsMask']); // obstructionMask
    
    // reconstruct the water surface
    var recon = ls_fun.fillWater(waterMask, obsMask, aoiBuffered);
    
    // calculate lakeMask after reconstructing the water surface
    var reconstructedLake = ls_fun.ExtractChannel(recon.select(['Reconstructed']), aoi.buffer(-50), MAXDISTANCE)
    .rename(['Reconstructed']);
    var reconstructedLakeAll = ls_fun.ExtractChannel(recon.select(['ReconstructedAll']), aoi.buffer(-50), MAXDISTANCE)
    .rename(['ReconstructedAll']);
    var rawLake = waterMask.and(reconstructedLake).rename(['lakeMask']);
    recon = recon.select(['obsMask']).addBands(reconstructedLake).addBands(rawLake).addBands(reconstructedLakeAll);
    
    
    var areaImage = calcAreaImage(recon.select(['lakeMask']))
    .addBands(calcAreaImage(recon.select(['obsMask'])))
    .addBands(calcAreaImage(recon.select(['Reconstructed'])))
    .addBands(calcAreaImage(recon.select(['ReconstructedAll'])));
    
    // add the pixel areas together to calculate total area
    var lakeArea = areaImage.reduceRegion({
      reducer: ee.Reducer.sum(), 
      geometry: aoiBuffered, 
      scale: 30});
      
    return(i.addBands(recon).setMulti(lakeArea).copyProperties(recon).set('refArea', f.get('AREASQKM')));
  });
  
  result
  .sort('timestamp')
  .filterMetadata('fillStatus', 'equals', 'success').aside(print)
  
  var halfArea = aoi.area(10).divide(2).divide(1000000).aside(print);
  
  var chart = ui.Chart.feature.byFeature({
    features: result
    
    
    .sort('timestamp'), 
    xProperty: 'timestamp', 
    yProperties: ['refArea', 'lakeMask', 'Reconstructed', 'ReconstructedAll']})
    .setChartType('ScatterChart')
    .setOptions({
      title: 'Changes in lake area: ' + name + ' (size of lake polygon: ' + String(f.get('AREASQKM').getInfo()) + ' km^2)',
      vAxis: {title: 'Lake area (km^2)'},
      hAxis: {title: 'Date'},
      curveType: 'none',
      lineWidth: 1,
      pointSize: 4,
      explorer: {
        keepInBounds: true,
        actions: ['dragToZoom', 'rightClickToReset']
      },
      series: [
        {color: 'black', labelInLegend: 'Lake polygon area', pointSize: 0},
        {color: 'blue', labelInLegend: 'Lake area (exposed)'},
        {color: 'red', labelInLegend: 'Lake area recon 1'},
        {color: 'green', labelInLegend: 'Lake area recon 2'}
      ]
    });
    
  chart.style({
    stretch: 'vertical',
    minHeight: '800px'
  });
  
  chart.onClick(function(x, y, z) {
    var f = ee.Image(result
    .filterMetadata('timestamp', 'equals', x)
    .filterMetadata(z, 'equals', y)
    .first());
    
    var imgId = f.get('image_id');
    var img = ee.Image(dat.filterMetadata('LANDSAT_ID', 'equals', imgId).first());
    Map.centerObject(aoi);
    layers.set(0, ui.Map.Layer(img, {bands: ['Red', 'Green', 'Blue'], min: 0, max: 2500}, 'rgb image', true));
    layers.set(1, ui.Map.Layer(img.normalizedDifference(['Green', 'Swir1']), {min: -1, max: 1, palette: ['#d8b365','#f5f5f5','#5ab4ac']}, 'mndwi image', false));
    layers.set(2, ui.Map.Layer(f.select(['lakeMask']).selfMask(), {palette: ['blue']}, 'exposed lake area', true));
    layers.set(3, ui.Map.Layer(f.select(['Reconstructed']).selfMask(), {palette: ['red']}, 'lake area (fill in clouded area only)', false, 0.8));
    layers.set(4, ui.Map.Layer(f.select(['ReconstructedAll']).selfMask(), {palette: ['green']}, 'lake area (fill in entire lake area)', true, 0.8));
    layers.set(5, ui.Map.Layer(f.select(['fmask']).gte(2).selfMask(), {palette: ['yellow']}, 'obstructions', false, 0.5));
    layers.set(6, ui.Map.Layer(occ.selfMask(), {palette: ['#9e0142','#d53e4f','#f46d43','#fdae61','#fee08b','#ffffbf','#e6f598','#abdda4','#66c2a5','#3288bd','#5e4fa2'], min: 1, max: 100}, 'jrc_occ', false, 0.7));
    layers.set(7, ui.Map.Layer(lakes, {color: 'grey'}, 'lake polygons', true, 0.5));
    
    //diagnose water classification
    var wm = ls_fun.CalculateWaterAddFlagsSR(img, waterClassification).select('waterMask');
    layers.set(8, ui.Map.Layer(wm.selfMask(), {palette: ['blue']}, 'waterClassification', false, 0.5));
    });
  
  chartPanel.widgets().set(0, chart);
  chartPanel.widgets().set(1, paragraphPanel);
  
  Export.table.toDrive({
    collection: result, 
    description: name + '_lake_area', 
    folder: '', 
    fileNamePrefix: name + '_lake_area', 
    fileFormat: 'csv'});
});

Map.setOptions('satellite');
Map.add(lakeSelector);
var chartPanel = ui.Panel([], ui.Panel.Layout.Flow('vertical'), {position: 'bottom-right', stretch: 'vertical', maxHeight: '800px'});
var paragraph = [
  'Lake polygon area: reference lake areas (km^2) from the AREASQKM property of the lake polygon file.',
  'Lake area (exposed) km^2: area of the lake surface that is not obstructed',
  'Lake area recon 1 km^2: lake area exposed + estimated cloud-covered lake area (estimated from water occurrence map)',
  'Lake area recon 2 km^2: lake area estimated directly from water occurrence map (Pekel et al, 2017).'
  ];
var txtStyleMain = {position: 'top-center', stretch: 'horizontal', textAlign: 'left', padding: '2px 10px 2px 10px', margin: '0px'};
var paragraphPanel = createParagraphPanel(paragraph, txtStyleMain);

ui.root.insert(1, chartPanel);
ui.root.setLayout(ui.Panel.Layout.flow('vertical', false));

