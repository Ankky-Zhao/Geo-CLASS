/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var geo2018 = ee.Image("users/eeranyartrodrigo/geoMediana/gm_2018_MX_014009"),
    geo2019 = ee.Image("users/eeranyartrodrigo/geoMediana/gm_2019_MX_014009"),
    vis = {"min":0,"max":8,"palette":["1c0dff","05450a","086a10","54a708","78d203","009900","b6ff05","f9ffa4","a5a5a5"]},
    visParams = {"bands":["B3","B2","B1"],"min":0,"max":3000,"gamma":1.4},
    pabellon = ee.FeatureCollection("users/eeranyartrodrigo/Pabellon"),
    geometry = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-119.28837045798946, 33.60118937697757],
          [-119.28837045798946, 18.922211194243925],
          [-94.23954233298947, 18.922211194243925],
          [-94.23954233298947, 33.60118937697757]]], null, false);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
var cloudMaskL457 = function(image) {

  

  var qa = image.select('pixel_qa');

  // If the cloud bit (5) is set and the cloud confidence (7) is high

  // or the cloud shadow bit is set (3), then it's a bad pixel.

  var cloud = qa.bitwiseAnd(1 << 5)

                  .and(qa.bitwiseAnd(1 << 7))

                  .or(qa.bitwiseAnd(1 << 3));

  // Remove edge pixels that don't occur in all bands

  var mask2 = image.mask().reduce(ee.Reducer.min());

  return image.updateMask(cloud.not()).updateMask(mask2);

}



var landsat = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')

                .filterDate('2018-01-01', '2018-12-31')

                .map(cloudMaskL457)

                .select(['B1','B2','B3','B4','B5','B6'])

                .median()













print('landsat: ', landsat)

Map.addLayer(landsat.clip(pabellon),visParams,'RGB composite',false)

// Renombrar bandas

geo2018 = geo2018.rename(['B1','B2','B3','B4','B5','B6'])

geo2019 = geo2019.rename(['B1','B2','B3','B4','B5','B6'])



var bands = ['NDVI','NDWI','BSI']



//LandCover Type4

var lc = ee.ImageCollection('MODIS/006/MCD12Q1')

         .filterDate('2018-01-01', '2018-12-31')

         .select('LC_Type4')

         .first()

         

//reproyectar LC







//Construir dataset y cortar por ANP



var input = geo2018.addBands(lc.select('LC_Type4').rename('lc'))



input = input.clip(pabellon)

print('input: ', input)



//geomediana a resolución MODIS

var proj = input.select('lc').projection()

// Get the forest cover data at MODIS scale and projection.

var reducedGeo = input

    // Force the next reprojection to aggregate instead of resampling.

    .reduceResolution({

      reducer: ee.Reducer.median(),

      maxPixels: 512

    })

    // Request the data at the scale and projection of the MODIS image.

    .reproject({

      crs: proj

    })





// Display the aggregated, reprojected forest cover data.









Map.centerObject(pabellon)

Map.addLayer(input,visParams,'RGB composite',false)

Map.addLayer(reducedGeo.round(), visParams, 'Geomedian reduced',false);

Map.addLayer(input.select('lc'),vis,'LandCover 4',false)



//Añadir cálculo NDVI

input = input.addBands(input.normalizedDifference(['B4','B3']).rename('NDVI'))

input = input.addBands(input.normalizedDifference(['B2','B4']).rename('NDWI'))

input = input.addBands(input.expression('(B2+B4)/(B2-B4)',{'B4':input.select('B4'),'B2':input.select('B2')}).rename('BSI'))







//Obtener puntos de training


var stratified = input.stratifiedSample(300, 'lc', pabellon, 500,null,1)

var stratified2 = input.stratifiedSample(80, 'lc', pabellon, 500,null,8)



print('train stratified size: ', stratified.size())

print('test stratified size: ', stratified2.size())








var rf = ee.Classifier.smileRandomForest({

    numberOfTrees: 15,

    seed: 1,

    

    

    bagFraction: 0.999

  })

  .train({

    features: stratified,

    classProperty: 'lc',

    inputProperties: bands

  })



var predicted = input.select(bands).classify(rf)

Map.addLayer(predicted.select('classification'),vis,'Predicted',false)



//Accuracy Assesment

var trainAccuracy = rf.confusionMatrix();



print('Training overall accuracy: ', trainAccuracy.accuracy());



// Classify the validation data.



var validated = stratified2.classify(rf)





// Get a confusion matrix representing expected accuracy.

var testAccuracy = validated.errorMatrix('lc', 'classification');



print('Validation overall accuracy: ', testAccuracy.accuracy());



// Define a boxcar or low-pass kernel.






// Get the forest cover data at MODIS scale and projection.

var reduced = predicted

    // Force the next reprojection to aggregate instead of resampling.

    .reduceResolution({

      reducer: ee.Reducer.median(),

      maxPixels: 512

    })

    // Request the data at the scale and projection of the MODIS image.

    .reproject({

      crs: proj

    })





// Display the aggregated, reprojected forest cover data.

Map.addLayer(reduced.round(), vis, 'Predicted LC reduced',false);



geo2019 = geo2019.addBands(geo2019.normalizedDifference(['B4','B3']).rename('NDVI'))

geo2019 = geo2019.addBands(geo2019.normalizedDifference(['B2','B4']).rename('NDWI'))

geo2019 = geo2019.addBands(geo2019.expression('(B2+B4)/(B2-B4)',{'B4':geo2019.select('B4'),'B2':geo2019.select('B2')}).rename('BSI'))



var lc_2019 = geo2019.clip(pabellon).classify(rf)

var reducedLC = lc_2019

    // Force the next reprojection to aggregate instead of resampling.

    .reduceResolution({

      reducer: ee.Reducer.median(),

      maxPixels: 512

    })

    // Request the data at the scale and projection of the MODIS image.

    .reproject({

      crs: proj

    })





var reducedGeo2019 = geo2019

    // Force the next reprojection to aggregate instead of resampling.

    .reduceResolution({

      reducer: ee.Reducer.median(),

      maxPixels: 512

    })

    // Request the data at the scale and projection of the MODIS image.

    .reproject({

      crs: proj

    })

// Display the aggregated, reprojected forest cover data.

Map.addLayer(geo2019.clip(pabellon),visParams,'RGB composite 2019',false)

Map.addLayer(reducedGeo2019.clip(pabellon),visParams,'RGB composite reduced 2019',false)

Map.addLayer(lc_2019,vis,'Predicted LC 2019',false)

Map.addLayer(reducedLC.round(), vis, 'Predicted LC reduced 2019',false);







//histogramas

var h1 = ui.Chart.image.histogram(reduced.round(),pabellon,500,5)

print(h1)



var h2 = ui.Chart.image.histogram(reducedLC.round(),pabellon,500,5)

print(h2)







var evo = ee.ImageCollection('MODIS/NTSG/MOD16A2/105')

                  .filter(ee.Filter.date('2014-04-01', '2014-06-01'));

var evapotranspiration = evo.select('ET');

var evapotranspirationVis = {

  min: 0.0,

  max: 300.0,

  palette:

      ['a50000', 'ff4f1a', 'f1e342', 'c7ef1f', '05fff3', '1707ff', 'd90bff'],

};

Map.setCenter(6.746, 46.529, 2);

Map.addLayer(evapotranspiration.first().clip(pabellon), evapotranspirationVis, 'Evapotranspiration');



